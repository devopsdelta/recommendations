"""
Models for Recommendation Service

All of the models are stored in this module

Models
------
Base Model          - Represents columns that are used for all tables
Recommendation      - A recommendation based on a product with similar attributes
Recommendations     - Each product and it's weight
Recommendation Type - A lookup table for the type of recommendations (i.e. up-sell, cross-sell, accessory, etc)

Attributes:
-----------
Base Model
  __abstract__           - Indicates that this object must be inherited
  _created    (DateTime) - The DateTime that this record was created
  _updated    (DateTime) - The DateTime that this record was last _updated

Recommendation_type
  rec_type_id  (int)      - Auto incrimented id (PK)
  description  (char)     - The description of this type (i.e. up-sell, cross-sell, accessory, etc)
  is_active    (boolean)  - Determines if this recommendation type can be used
  product_query(char)     - Store query that should be used against the product
                            API to get a list of potiential recommendations and then apply weight to

Recommendation
  rec_id      (int)      - Auto incrimented id (PK)
  product_id  (int)      - the id of the product that will be used to get recommendations for

Recommendations
  prod_rec_id  (int)     - Auto incrimented id (PK)
  rec_id       (int)     - foreign key to Recommendation table
  weight       (float)   - Weight determined by our algorithm
  rec_prod_id  (int)     - The id of the product being recommended
  rec_type_id  (int)     - The type of recommendation
  dislike_count(int)     - Was the provided disliked

"""
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, ForeignKey, Integer, String, Float, Boolean
from sqlalchemy import Index
from sqlalchemy.orm import relationship, backref

Base = declarative_base()

class DataValidationError(Exception):
    """ Used for an data validation errors when deserializing """
    pass

class BaseModel(Base):
    __abstract__ = True
    _created = Column(DateTime, default=func.now())
    _updated = Column(DateTime, default=func.now(), onupdate=func.now())

class Recommendation_type(BaseModel):
    """
    Class that represents a Recommendation Type
    """
    __tablename__ = 'recommendation_type'
    # Primary key
    rec_type_id = Column(Integer, index = True, primary_key=True)
    description = Column(String(40), unique=True, nullable=False)
    is_active = Column(Boolean)
    #product_query = Column(String(255), nullable=False) \
    # Category="originalproductCategory", Price > current Product Price + 1

class Recommendation(BaseModel):
    """
    Class that represents a Recommendation
    """
    __tablename__ = 'recommendation'
    rec_id = Column(Integer, index = True, primary_key = True)
    product_id = Column(Integer, unique=True)

class Recommendations(BaseModel):
    """
    Class that represents Recommendations
    """
    __tablename__ = 'recommendations'
    prod_rec_id = Column(Integer, index = True, primary_key = True)
    rec_id = Column(Integer, ForeignKey('recommendation.rec_id'), nullable=False)
    rec_product_id = Column(Integer, nullable=False)
    weight = Column(Float, nullable=False)
    rec_type_id = Column(Integer, ForeignKey('recommendation_type.rec_type_id'), nullable=False)
    dislike_counter = Column(Integer, nullable=True, default=0)

    @staticmethod
    def all():
        """ Returns all of the Products in the database """
        return [recommendation for recommendation in Recommendation.data]

    @staticmethod
    def remove_all():
        """ Removes all of the Recommendation from the database """
        del Recommendation.data[:]
        return Recommendation.data

    @staticmethod
    def find_by_id(id, cat):
        """ Finds a Recommendation by it's ID """
        if not Recommendation.data:
            return None

        recommendations = [recommendation for recommendation in Recommendation.data if recommendation.id == id]

        if recommendations:
            return recommendations[0]

        return None

    @staticmethod
    def find_by_category(value):
        """ Finds a Recommendation by it's Category """

        if not Recommendation.data:
            return None

        search_criteria = value.lower()
        results = []

        for recommendation in Recommendation.data:
            if search_criteria in recommendation.recommendation['category']:
                results.append(recommendation)

        return results
